from sage.all import *
from classes.coordinates import TableauColumn
from classes.variety import FlagVariety
from classes.monomial import TableauMonomial
from classes.polynomial import TableauPolynomial
from classes.tableau_relation import TableauRelation

class ApplyRelation:
    def __init__(self,monomial):
        self.monomial = monomial.deepcopy()
        self.poly = TableauPolynomial([monomial.deepcopy()])
        self.state = 0   #0:"Not started", 1:"Started", 2:"Finished"
        self.steps = []

    def do_one_step(self,ncpair,fname=None,save_data=True,step_name="",verbose=False):
        if self.state == 2:
            return
        self.state = 1

        R = TableauRelation(self.monomial.variety,ncpair)

        temp_m=None
        R_idx = None
        poly_idx = None
        for r in range(len(R)):
            for p in range(len(self.poly)):
                v = self.poly[p].vec-R[r].vec
                try:
                    temp_m = TableauMonomial(self.monomial.variety,-self.poly[p].coef*R[r].coef,vec=v)
                    R_idx = r
                    poly_idx = p
                    break
                except:
                    pass
        if not(isinstance(temp_m,TableauMonomial)):
            return False
        step_details = {"poly":self.poly,"relation":R,"R_idx":R_idx+1,"poly_idx":poly_idx+1,"term_m":temp_m,"new_relation":None,"result":None,"factors":[]}
        self.steps.append(step_details)

        R = R*TableauPolynomial([temp_m])
        self.steps[-1]["new_relation"] = R

        self.poly = self.poly + R
        self.steps[-1]["result"] = self.poly

        for p in self.poly:
            m = TInvariantMonomial(p.variety,monomial=p)
            (f1,f2) = m.factor_()
            if not(isinstance(f2,TableauMonomial)):
                return False
            self.steps[-1]["factors"].append((f1,f2))

        self.print_step(verbose=verbose)
        if save_data and fname!=None:
            self.save_step(fname=fname,step_name=step_name)
        if verbose:
            print(f"done straigntaining for {step_name}")
        return True

    def print_step(self,i=0,verbose=True):
        if i >= len(self.steps):
            return
        if not verbose:
            return
        d = self.steps[i]
        print("===========================Step "+str(i)+"===========================")
        print("Polynomial to straighten:")
        print(d["poly"])
        print("Relation being applied is")
        print(d["relation"])
        print(f"We replace term {d['poly_idx']} in above polynomial using the term {d['R_idx']} in relation.")
        print("Multiply by following monomial to relation:")
        print(d["term_m"])
        print("we get")
        print(d["new_relation"])
        print(f"Using result of above step, replace the term {d['poly_idx']} in polynomial in step 1, we get:")
        print(d["result"])
        print("Each monomial in above result can be factored directly and the factors are")
        for i in range(len(d["result"])):
            print(f"Factors of term {i} are")
            print(d["factors"][i][0])
            print(d["factors"][i][1])
        print("=====================================================================")

        return

    def save_step_gr37(self,i=0,fname=None,step_name=""):
        if i >= len(self.steps) or fname==None:
            return
        d = self.steps[i]
        f = open(fname,"a")
        f.writelines(f"\n==============Hilbert Basis element: {step_name}=================\n")
        f.writelines(f"Claim [{step_name}]:\n\n  The T-invariant standard monomial written below is in algebra generated by T-invariant monomials of strictly smaller degree.\n")
        f.writelines(str(d["poly"]))
        f.writelines("\n\nProof: \n  Consider the Plucker relation:\n\n")
        f.writelines(str(d["relation"]))
        f.writelines(f"\n\n  Using the term {d['R_idx']} in relation, we rewrite above monomial. To do this, Multiply by following monomial to the relation:\n")
        f.writelines(str(d["term_m"]))
        f.writelines("\n\n  we get following new relation\n\n")
        f.writelines(str(d["new_relation"]))
        f.writelines(f"\n\n  Observe that the term {d['R_idx']} in above relation is exactly the monomial in question. Hence monomial in claim is equal to\n\n")
        f.writelines(str(d["result"]))
        f.writelines("\n\n  Each term in above result can be written as product of T-invariant monomials of strictly smaller degree. factors are presented below.\n")
        for i in range(len(d["result"])):
            f.writelines(f"\n  Factors of term {i+1} are\n")
            f.writelines(str(d["factors"][i][0]))
            f.writelines("  \n")
            f.writelines(str(d["factors"][i][1]))
            f.writelines("  \n")
        f.writelines("\n  Hence claim is proved.\n")
        f.writelines("===================================================================")
        f.close()
        return

    '''save_step is only implemented for gr37'''
    def save_step(self,i=0,fname=None,step_name=""):
        self.save_step_gr37(i,fname=fname,step_name=step_name)
        return

        if i >= len(self.steps) or fname==None:
            return
        d = self.steps[i]
        f = open(fname,"w")
        f.writelines("===========================Step "+str(i)+"===========================\n")
        f.writelines("Polynomial to straighten:\n")
        f.writelines(str(d["poly"]))
        f.writelines("\nRelation being applied is\n")
        f.writelines(str(d["relation"]))
        f.writelines(f"\nWe replace term {d['poly_idx']} in above polynomial using the term {d['R_idx']} in relation.\n")
        f.writelines("Multiply by following monomial to relation:\n")
        f.writelines(str(d["term_m"]))
        f.writelines("\nwe get\n")
        f.writelines(str(d["new_relation"]))
        f.writelines(f"\nUsing result of above step, replace the term {d['poly_idx']} in polynomial in step 1, we get:\n")
        f.writelines(str(d["result"]))
        f.writelines("\nEach monomial in above result can be factored directly and the factors are\n")
        for i in range(len(d["result"])):
            f.writelines(f"\nFactors of term {i} are\n")
            f.writelines(str(d["factors"][i][0]))
            f.writelines(str(d["factors"][i][1]))
        f.writelines("=====================================================================")
        f.close()
        return
